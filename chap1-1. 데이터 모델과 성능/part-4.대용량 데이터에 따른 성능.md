## PART 4. 대용량 데이터에 따른 성능
: 테이블 반정규화 중 테이블 분할 관련

🔹 블록 : 테이블의 데이터 저장 단위

### ✅ 대량 데이터 발생으로 인한 현상
: 블록 I/O 획수 증가 → 디스크 I/O 가능성 상승 (디스크 I/O시 성능 저하)

**🔹 로우 체이닝 (Row Chaining)**
: 로우의 길이가 너무 길어서 데이터 블록 하나에 데이터가 모두 저장되지 않고 두 개 이상의 블록에 걸쳐 하나의 로우가 저장되어 있는 형태

**🔹 로우 마이그레이션 (Row Migration)**
: 데이터블록에서 수정이 발생하면 수정된 데이터를 해당 데이터 블록에서 저장하지 못하고 다른 블록의 빈 공간을 찾아 저장하는 방식 </br>
→ 로우 체이닝과 로우 마이그레이션이 발생하여 많은 블록에 데이터가 저장되면 DB 메모리에서 디스크 I/O가 발생할 때 많은 I/O가 발생하여 성능저하 발생.
트랜잭션을 분석하여 적절하게 1:1관계로 분리함으로써 성능향상이 가능하도록 해야 한다.

### ✅ PK에 의해 테이블을 분할하는 방법 (파티셔닝)

**🔹파티셔닝 (Partitioning)**
: 테이블 수평분할 기법. 논리적으로는 하나의 테이블이지만 물리적으로 여러 데이터 파일에 분산 저장, 데이터 조회 범위를 줄여 성능 향상

1. **RANGE PARTITION** : 대상 테이블이 날짜 또는 숫자 값으로 분리가 가능하고 각 영역별로 트랜잭션이 분리되는 경우
   즉, 데이터 값의 범위를 기준으로 분할
    ```sql
    // ex)
    PARTITION BY COL1
    ORDER BY COL3
    RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW
    ```

2. **LIST PARTITON** : 지점, 사업소 등 핵심적인 코드값으로 PK가 구성되어 있고 대량의 데이터가 있는 테이블의 경우
   즉, 특정한 값을 기준으로 분할
3. **HASH PARTITION** : 지정된 HASH 조건에 따라 해시 알고리즘이 적용되어 테이블이 분리
   즉, 해시 함수를 적용하며 분할, DBMS가 알아서 분할 관리, 데이터 위치를 알 수 없음
4. **COMPOSITE PARTITON** : 여러 파티션 기법을 복합적으로 사용하여 분할

**※ 파티션 인덱스 (Partition Index)**
- Global Index, Local Index : 여러 파티션에서 단일 인덱스 사용, 파티션 별로 각자 인덱스 사용
- Prefixed Index, Non-Prefixed Index : 파티션키와 인덱스키 동일, 파티션키와 인덱스키 구분

### ✅ 테이블에 대한 수평/수직분할의 절차

1. 데이터 모델링을 완성한다.
2. DB 용량산정을 한다.
3. 대량 데이터가 처리되는 테이블에 대해 트랜잭션 처리 패턴을 분석한다.
4. 컬럼 단위로 집중화된 처리가 발생하는지, 로우 단위로 집중된 처리가 발생하는지 분석하여 집중화된 단위로 테이블을 분리하는 것을 검토한다.